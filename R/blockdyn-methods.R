# Author: Jacob Nabe-Nielsen
# Date: 2 September 2020
# Licence GPL v3
# Description: Methods and classes for reading and summarizing DEPONS output
#    stored in 'PorpoisePerBlock'-files, i.e. population dynamics for different
#    parts of the landscape.

#' @title  DeponsBlockdyn-class and methods
#' @description Classes and methods for analyzing and plotting changes in
#' population size for different parts of the landscape (i.e. different 'blocks')
#' @slot title Character. Name of the object or simulation
#' @slot landscape Character. Identifier for the landscape used in the DEPONS
#' simulations. The landscapes 'DanTysk', 'Gemini', 'Kattegat', 'North Sea',
#' 'Homogeneous', and 'User defined' are distributed with the DEPONS model.
#' @slot simdate \code{\link{POSIXlt}} object with the date and time when the simulation was
#' finished. This is read from the name of the imput file.
#' @slot simstart POSIXlt object with the first day of the simulation, i.e.
#' the first day in the period that the simulations are intended to represent in
#' the real world.
#' @slot data Data frame with simulation output.
#' @details The data frame with simulation output includes the columns 'tick',
#' which indicates the number of half-hourly time steps since the start of the
#' simulation; a column 'count.X' with the number of animals in each block at
#' each tick, and 'simtime', which shows the real-world equivalent to 'tick.
#' @exportClass DeponsBlockdyn
#' @examples a.DeponsBlockdyn <- new("DeponsBlockdyn")
#' a.DeponsBlockdyn
#' @note DeponsBlockdyn-objects are usually read in from csv files produced during
#' DEPONS simulations. These files are named 'PorpoisePerBlock.XXX.csv', where XXX
#' indicates the date and time when the simulation was finished.
#' @seealso \code{\link[DEPONS2R]{plot.DeponsBlockdyn}} and
#' \code{\link[DEPONS2R]{read.DeponsBlockdyn}}.
setClass(Class="DeponsBlockdyn",
         slots=list(title="character", landscape="character", simdate="POSIXlt",
                    simstart="POSIXlt", data="data.frame")
)


setMethod("initialize", "DeponsBlockdyn",
          function(.Object) {
            .Object@title <- "NA"
            .Object@landscape <- "NA"
            .Object@simdate <- as.POSIXlt(NA)
            .Object@simstart <- as.POSIXlt(NA)
            .Object@data <- data.frame("tick"=NA, "count.X"=NA, "simtime"=NA)
            return((.Object))
          }
)


setMethod("show", "DeponsBlockdyn",
          function(object) {
            cat("class:    \t", "DeponsBlockdyn \n")
            cat("title:    \t", object@title, "\n")
            cat("landscape:\t", object@landscape, "\n")
            cat("simdate:  \t", as.character(object@simdate), "\n")
            cat("data     \t tick   \t count.X \t simtime \n" )
            rnd <- function(n) sprintf(n, fmt='%#.3f')
            l.obj <- nrow(object@data)
            # cat("   start:\t",  object@data$tick[1], "\t, object@data$count[1], "\t", as.character(object@simstart), "\n")
            # cat("   mean:\t",  rnd(mean(object@data$tick)), "  \t",
            #     "NA  \t", rnd(mean(object@data$count)))
            #     "\t", rnd(mean(object@data$energy)), "\t", rnd(mean(object@data$lenergy)),
            #     "\t NA \n")
            # if(!is.null(l.obj)) {
            #   cat("   end:  \t",  object@data$tick[l.obj], "    \t", object@data$count[l.obj],
            #       "    \t", rnd(object@data$energy[l.obj]), "   \t", rnd(object@data$lenergy[l.obj]),
            #       "\t", as.character((object@data$simtime[l.obj])))
            # }
          }
)

#' @title Reading simulated population count for blocks
#' @description Function for reading DEPONS simulation output with number of
#' animals per block for each time step.
#'
#' @param fname Name of the file (character) that contains movement data
#' generated by DEPONS. The name includes the path to the directory if this is
#' not the current working directory.
#' @param title Optional character string giving name of simulation
#' @param landscape The landscape used in the simulation
#' @param simdate Optional POSIXlt object with date of simulation. If
#' not provided this is obtained from name of input file
#' @param simstart The start of the period that the  simulation represents, i.e.
#' the real-world equivalent of 'tick 1' (POSIXlt)
#' @param tz Time zone used in simulations. Defaults to UTC/GMT.
#' @seealso See \code{\link{DeponsBlockdyn-class}} for details on what is stored in
#' the output object.
#' @export read.DeponsBlockdyn
read.DeponsBlockdyn <- function(fname, title="NA", landscape="NA", simdate="NA",
                           simstart="NA", tz="UTC") {
  raw.data <- utils::read.csv(fname, sep=";")
  # Get sim date and time from file name
  if (simdate=="NA")  simdate <- get.simdate(fname)
  if (simstart=="NA")  simstart <- NA
  all.data <- new("DeponsBlockdyn")
  all.data@title <- title
  all.data@landscape <- landscape
  all.data@simdate <- as.POSIXlt(simdate, tz=tz)
  all.data@simstart <- as.POSIXlt(simstart, tz=tz)
  the.data <- utils::read.csv(fname, sep=";")

  ### STACK THE INPUT FILE !!!

  names(the.data) <- c("tick", "count")
  the.data$simtime <- as.POSIXlt(the.data$tick*30*60,
                                 origin=as.POSIXlt(simstart, tz=tz), tz=tz)
  all.data@data <- the.data
  return(all.data)
}



#' @title Plot a DeponsBlockdyn object
#' @description Plot population dynamics simulated with DEPONS
#' @aliases plot.DeponsBlockdyn
#' @param x DeponsBlockdyn object
#' @param y Not used
#' @param dilute Integer. Plot only one in every 'dilute' values. Defaults to
#' 5, which yields a plot of the first simulated value and one in every five of
#' the following values.
#' @param ... Optional plotting parameters
#' @param plot.energy If set to TRUE it plots the amount of energy stored in
#' simulated and in the landscape in addition to the population count
setMethod("plot", signature("DeponsBlockdyn", "missing"),
          function(x, y, dilute=5, plot.energy=FALSE, ...)  {
            if (!(dilute %% 1 == 0)) stop("'dilute' must be an integer")
            use.row <- x@data$tick %% dilute == 0
            use.row[1] <- TRUE
            graphics::par(mar=c(4.2, 4.2, 4, 4.2))
            if(!hasArg(ylab)) {
              ylab <- "count"
            } else {
              ylab <- as.character(list(...)[["ylab"]])
            }
            if(!hasArg(lwd)) {
              lwd <- 2
            } else {
              lwd <- as.character(list(...)[["lwd"]])
            }
            if(!hasArg(lty)) {
              lty <- 1
            } else {
              lty <- as.character(list(...)[["lty"]])
            }
            if(!hasArg(col)) {
              col <- "blue"
            } else {
              col <- as.character(list(...)[["col"]])
            }
            if(!hasArg(type)) {
              type <- "l"
            } else {
              type <- as.character(list(...)[["type"]])
            }
            if(!hasArg(axes)) {
              axes <- TRUE
            } else {
              axes <- list(...)[["axes"]]
            }
            if(!hasArg("ylim")) {
              ylim <- c(min(x@data$count), max(x@data$count))
            } else {
              ylim <- list(...)[["ylim"]]
            }
            if(!hasArg("main")) {
              main <- "DEPONS simulation output"
            } else {
              main <- x@title
            }
            # Make plot with either date or tick on x-axis
            if (!is.na(x@simstart)) {
              if(!hasArg("xlim")) {
                xlim <- NULL
              } else {
                xlim <- list(...)[["xlim"]]
              }
              if(!hasArg("xlab")) {
                xlab <- "year"
              } else {
                xlab <- list(...)[["xlab"]]
              }
              plot(x@data$simtime[use.row], x@data$count[use.row],
                   xlab=xlab, ylab=ylab, main=main, col=col, type=type,
                   xlim=xlim, ylim=ylim, axes=axes, lwd=lwd, lty=lty)
            } else {
              if(!hasArg("xlim")) {
                xlim <- c(min(x@data$tick), max(x@data$tick))
              } else {
                xlim <- list(...)[["xlim"]]
              }
              if(!hasArg("xlab")) {
                xlab <- "tick"
              } else {
                xlab <- list(...)[["xlab"]]
              }
              plot(x@data$tick[use.row], x@data$count[use.row],
                   xlab=xlab, ylab=ylab, main=main, col=col, type=type,
                   xlim=xlim, ylim=ylim, axes=axes, lwd=lwd, lty=lty)
            }
            if(plot.energy) {
              graphics::par(new=TRUE)
              plot(x@data$tick[use.row], x@data$energy[use.row],
                   col="red", axes=FALSE, xlab="", ylab="", type=type, lwd=lwd)
              graphics::par(new=TRUE)
              plot(x@data$tick[use.row], x@data$lenergy[use.row],
                   col="orange", axes=FALSE, xlab="", ylab="", type=type, lwd=lwd)
              graphics::axis(4)
              graphics::mtext("energy level", side=4, line=2.6)
              graphics::legend("bottomright", fill=c(col, "red", "orange"),
                     legend=c("population count", "animal energy level", "landscape energy"))
            }
          }
)


